<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_0) on Tue Aug 14 16:56:20 EDT 2012 -->
<TITLE>
edu.cmu.minorthird.text.mixup
</TITLE>

<META NAME="date" CONTENT="2012-08-14">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="edu.cmu.minorthird.text.mixup";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../edu/cmu/minorthird/text/learn/experiments/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../../../edu/cmu/minorthird/text/model/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?edu/cmu/minorthird/text/mixup/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package edu.cmu.minorthird.text.mixup
</H2>
Little language for creating annotations for text.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../../edu/cmu/minorthird/text/mixup/Mixup.html" title="class in edu.cmu.minorthird.text.mixup">Mixup</A></B></TD>
<TD>A simple pattern-matching and information extraction language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../../edu/cmu/minorthird/text/mixup/Mixup.MixupTokenizer.html" title="class in edu.cmu.minorthird.text.mixup">Mixup.MixupTokenizer</A></B></TD>
<TD>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../../edu/cmu/minorthird/text/mixup/MixupInterpreter.html" title="class in edu.cmu.minorthird.text.mixup">MixupInterpreter</A></B></TD>
<TD>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../../edu/cmu/minorthird/text/mixup/MixupProgram.html" title="class in edu.cmu.minorthird.text.mixup">MixupProgram</A></B></TD>
<TD>Modify a textlabeling using a series of mixup expressions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../../edu/cmu/minorthird/text/mixup/Statement.html" title="class in edu.cmu.minorthird.text.mixup">Statement</A></B></TD>
<TD>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Exception Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../../edu/cmu/minorthird/text/mixup/Mixup.ParseException.html" title="class in edu.cmu.minorthird.text.mixup">Mixup.ParseException</A></B></TD>
<TD>Signals an error in parsing a mixup document.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package edu.cmu.minorthird.text.mixup Description
</H2>

<P>
Little language for creating annotations for text.

    <h3>Mixup expressions</h3>

    At the simplest level, Mixup is a pattern language for 
    Spans (i.e. token sequences).  Each expression is defined 
    relative to labeling called a <A HREF="../../../../../edu/cmu/minorthird/text/TextLabels.html" title="interface in edu.cmu.minorthird.text"><CODE>TextLabels</CODE></A>.
    From the ground up:
    <ul>
    <li>A "simple pattern component" (SPC) matches a <em>single</em>
    token.  The SPC's include:
        <ul>
          <li><code>any</code> matches any token.
          <li><code>eq('foo')</code> matches the token <code>foo</code>.
            This can also be abbreviated as <code>'foo'</code> (in single quotes).
          <li><code>re('regex')</code> matches any token whose string
            value matches the given regular expression (from the java.util.regex
            package).  For instance, <code>re('^\\d+$')</code> matches any
            sequence of digits.
          <li><code>a(foo)</code> matches any token whose string value
          in the dictionary named <code>foo</code>.  Dictionaries are
          defined in a TextLabels. For example, <code>a(weekday)</code> might match
            one of 'sun', 'mon', 'tues', ..., 'sat'.
          <li><code>foo:bar</code> matches any token that has been tagged
            as having the value <code>bar</code> for the property <code>foo</code>.
            For example, <code>pos:det</code> might match a determiner.
          <li>SPC's can be negated by prefixing them with a bang (<code>!</code>).
            A conjunction of (optionally, negated) SPC's can be formed with angle
            brackets and commas, for instance: <code>&lt;a(month),!may&gt;</code>
            might match any of 'jan', 'feb', ..., 'april', 'june', ..., or 'december'.
        </ul>
      <li>A "repeated pattern component" (RPC) matches a <em>sequence of 
        adjacent tokens</em>.  An RPC is formed by appending one of the regex-like
        postfix operators <code>*</code>, <code>+</code>, <code>?</code>, or 
        <code>{i,j}</code> (where <code>i</code> and <code>j</code> are numbers)
        to a SPC.  The RPC <code>any*</code> can be abbreviated as <code>...</code>.
        An RPC matches any sequence of between <code>i</code> and <code>j</code>
        tokens such that every token in the sequence matches the underlying SPC.
        For example:
        <ul>
          <li><code>a(name){1,3}</code> matches any sequences of 1-3 tokens in the 'name' dictionary.
          <li><code>&lt;!a(punct),!'and'&gt;*</code> matches any sequence of tokens that are not in the
                'punct' dictionary and are not the token 'and'.
          <li><code>pos:noun?</code> matches the a one-token sequence with the 'pos' property set to
            'noun', or an empty sequence.
        </ul>
      <li>A "repeated pattern component" (RPC) can also be preceded by the 
        token 'L' or followed by the token 'R'.  An RPC modified by a 'L' matches unless
        the sequence it corresponds to can be extended one token to the left, and still
        match.  An RPC modified by a 'R' is analogous, but can't be extended to the right.
        For instance:
        <ul>
          <li><code>pos:adj+</code></li> matches any sequence of adjectives (if that's what 'pos:adj' means).
        However, <code>L pos:adj+</code> only matches a sequence of adjectives that does NOT have
        an adjective immediately to the left of it.
          <li><code>any{3,5}</code></li> matches any sequence of 3-5 tokens.
        However, <code>any{3,5} R</code> only matches a sequence of 3-5 tokens that can't be
        extended to the right---in other words, a sequence that is either exactly 5 tokens
        long, or which ends with the final token of a document.
        </ul>
      <li>A "repeated pattern component" (RPC) can also be either <code>@foo</code>
        or <code>@foo?</code>, where <code>foo</code> is a type.  The RPC <code>@foo</code>
        matches a span of type 'foo'.  The RPC <code>@foo?</code>matches either a span of
        type foo or an empty sequence.
      <li>A "mixup pattern" is a bunch of RPC's concatenated together.  A mixup
        pattern matches a token sequence if all tokens in the sequence match up
        with some RPC.  For instance:
        <ul>
          <li><code>... ',' 'Ph' '.' 'D'</code> matches any token sequence ending
            in ", Ph.D".
          <li><code>... '(' !eq(')'){,10} ')' ...</code> matches any sequence containing
              a parenthesized expression with less than 10 tokens in it.
        </ul>
      <li>Returning for a moment to the 'L' and 'R' operators, which say that a matched sequence
          can't be extended to the left of right...note that "can't be extended" can be 
          interpreted two ways:  either (a) any extension causes that RPC to fail to match
          or (b) any extension causes that RPC to fail to match, or else causes some
          other RPC pattern elsewhere in mixup pattern to fail.  The implemenentation
          current adopts the first interpretation, (a).  
    </ul>

    <h3>Extraction with Mixup</h3>

    Mixup is normally used for extraction, not matching.  For
    extraction, every Mixup expression should contain matching left
    and right square brackets.  For each Span that the expression is
    matched against, and for <em>every possible way the expression can
    be matched</em>, a subspan of the tokens matching the RPCS's
    inside the square brackets will be extracted.
    
    <p>For example:
      <ul>
      <li><code>... a(endOfSent) [ re('^[A-Z]') !a(endOfSent){3,}  a(endOfSent)] ...</code> 
        will extract "sentences" (roughly - really, every sequence of at least three words
        between things in the <code>endOfSent</code> dictionary.)
      <li><code>... [any any] ...</code> will extract all token bi-grams.
      </ul>


    <h3>Mixup Programs</h3>

          <p>
          The MixupProgram class allows a series of statements to be
          executed, one after another, in order to modify a text
          labeling.  Most of these statements are based on
          evaluating Mixup patterns, and then modifying the labels
          in response to those patterns.
          </p>

          The types of Mixup statements are:
          <ul>
            <li><code>defDict D = W1,W2,...,Wk</code>: adds words W1...Wk to dictionary D.
              If Wi is in double quotes, then Wi is interpreted as a filename, and
              all lines from that file are loaded in the dictionary.
            <li><code>provide ANNOTATION_TYPE</code>: puts a marker in the labels
              that annotations of the given type are present.
            <li><code>require ANNOTATION_TYPE,FILE</code>: sees if 
              annotations of the given type are present in the current labels.
              If not, the mixup program in 'file' is executed. (File might be in
              single quotes.)
            <li><code>defSpanType TYPE SPAN_GENERATOR</code>: adds all spans generated by the
              SPAN_GENERATOR to the given TYPE.  There are several types of SPAN_GENERATOR's.
              <ul>
                <li><code>=T: EXPR</code> runs the Mixup expression EXPR on every span
                  of type T, and returns all spans extracted by it.
                <li><code>=T- EXPR</code> runs the Mixup expression EXPR on every span
                  of type T, and returns all spans S in T such that nothing was successfully
                  extracted by EXPR.
                <li><code>=T~ re REGEX,N</code> runs the Java 1.4 regular expression REGEX
                  on the string associated with each span S in T, and returns the span
                  associated with the N-th group in that REGEX.  If the N-th group of the regex 
                  matches something that doesn't align with token boundaries, the closest
                  legal token span will be used instead.
              </ul>
            <li><code>defSpanProp PROP:VAL SPAN_GENERATOR</code>:
            same, but asserts that property PROP has value VAL for all generated spans.
            <li><code>defoTokenProp PROP:VAL SPAN_GENERATOR</code>:
            same, but asserts that property PROP has value VAL for all tokens contained
            in a generated span.
          </ul>

    <h3>An Example Mixup Program</h3>

Here's an extended example.

<font -1><pre>  
//=============================================================================
// Extract phrases about cells from biomedical captions.
//
// known current bugs:
//  need better sentence-starting rules, not using stems
//  (sentence start should be based on linguistically proper use of ":")
//  need to discard things with unbalanced parens
// undesirable examples:        
//  "in Hela-tet Of f cells" extracts "f cells"
//  "in contrast cells" extracts "in contrast cells"
//  "respective cells" extracts "respective cells"
//=============================================================================

// words that might start a plural noun phrase about cells
defDict pluralStart = ,, no, with, within, from, of, the, these, all, in, on, only, for, by, to, other, 
        have, indicate, represent, show, and, or;

// end of a plural noun phrase about cells - ie, a plural cell-related noun
defDict pluralEnd = cells,strains,clones;

// end of a singular noun phrase about cells
defDict singEnd = cell,strain,clone;

// start of a singular noun phrase about cells
defDict singStart = ,, with, from, of, the, in, on, or, a, an, each, to, other, indicate, represent, 
        and, or, per;

// numbers
defDict number = one, two, three, four, five, six, seven, eight, nine, ten, eleven, twelve,
        thirteen, fourteen, fifteen, sixteen, seventeen, eighteen, nineteen, twenty;

// simplify syntax for these, since there's no good way to quote them
defDict openParen = (;
defDict closeParen = );

// 'context' is anything near a cell end.  This is used to restrict search

defSpanType end =: ... [a(pluralEnd)] ... || ... [a(singEnd)] ...;
defSpanType context =: any+ [ any{15} @end any{2}] ... ||  [ any{,15} @end any{2}] ... ;

// the start of a sentence might have a panel label like (a) before it.

defSpanType sentStart =context: ... ['.' a(openParen) !a(closeParen){1,4} a(closeParen)] ... ;
defSpanType sentStart =context: ... ['.' ] re('^[A-Z]') ... ;

// something to ignore (not extract) that precedes a plural noun phrase

defSpanType ignoredPluralStart =context: ... [stem:a(pluralStart)] <!a(number),!re('^[0-9]+$')> ...;
defSpanType ignoredPluralStart =context: ... [stem:a(pluralStart) a(number) ] ...; 
defSpanType ignoredPluralStart =context: ... [stem:a(pluralStart) re('^[0-9]+$') ] ...; 
defSpanType ignoredPluralStart =context: ... [@sentStart] ...;

// something to ignore (not extract) that precedes a singular noun phrase

defSpanType ignoredSingStart =context: ... [stem:a(singStart)] ...;
defSpanType ignoredSingStart =context: ... [@sentStart] ...;

// don't allow 'breaks' (commands, periods, etc) in the adjectives that qualify a 
// cell-related noun.

defDict breakPunct = ,, .;
defSpanType qualifiers =context: 
        ... [<!stem:a(pluralStart),!stem:a(pluralEnd),!stem:a(singStart),!stem:a(singEnd),!a(breakPunct)>{1,8}] ...;

// finally define noun phrases as start,qualifiers,end

defSpanType cell =context: ... @ignoredPluralStart [@qualifiers a(pluralEnd)] ... ;
defSpanType cell =context: ... @ignoredSingStart [@qualifiers a(singEnd)] ... ;

// other cases seem to be like 'strain XY123' and 'strain XY123-fobar'

defSpanType cell =context: ... ['strain' re('^[A-Z]+[0-9]+$') '-' any] ... ;
defSpanType cell =context: ... ['strain' re('^[A-Z]+[0-9]+$') !'-'] ... ;
</pre></font>

    <hr>
    <address><a href="mailto:wcohen@cs.cmu.edu"></a></address>
<!-- Created: Mon Jul 14 16:06:19 Eastern Daylight Time 2003 -->
<!-- hhmts start -->
Last modified: Sun Feb 08 20:31:21 Eastern Standard Time 2004
<!-- hhmts end -->
<P>

<P>
<DL>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../edu/cmu/minorthird/text/learn/experiments/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../../../edu/cmu/minorthird/text/model/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?edu/cmu/minorthird/text/mixup/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
