package edu.cmu.minorthird.text;import org.apache.log4j.Logger;import java.io.*;import java.util.*;/** * Loads and saves the contents of a TextLabels into a file. * * Labels can be loaded from operations (see importOps) or from a serialized TextLabels object. * Labels can be serialized or types can be saved as operations, xml, or plain lists. * * @author William Cohen*/public class TextLabelsLoader{	private static Logger log = Logger.getLogger(TextLabelsLoader.class);	/** Spans in labels are a complete list of all spans. */	static final public int CLOSE_ALL_TYPES=1;	/** If a document has been labeled for a type, assume all spans of that type are there. */	static final public int CLOSE_TYPES_IN_LABELED_DOCS=2;	/** Make no assumptions about closure. */	static final public int DONT_CLOSE_TYPES=3;  static final public int CLOSE_BY_OPERATION = 4;  public static final String[] CLOSURE_NAMES = {"CLOSE_ALL_TYPES", "CLOSE_TYPES_IN_LABELED_DOCS", "DONT_CLOSE_TYPES", "CLOSE_BY_OPERATION"};	private int closurePolicy = CLOSE_BY_OPERATION;	/** Set the closure policy.	 * @param policy one of CLOSE_ALL_TYPES, CLOSE_TYPES_IN_LABELED_DOCS, DONT_CLOSE_TYPES	 */	public void setClosurePolicy(int policy) { this.closurePolicy = policy; }	/** Create a new labeling by importing from a file with importOps.	 */	public MutableTextLabels loadOps(TextBase base,File file) throws IOException,FileNotFoundException	{		MutableTextLabels labels = new BasicTextLabels(base);		importOps(labels,base,file);		return labels;	}	/**   * Load lines modifying a TextLabels from a file.   * There are four allowed operations: addToType, closeType, closeAllTypes, setClosure   *   * For addToType:   *   The lines must be of the form: <code>addToType ID LOW LENGTH TYPE</code> where ID is a	 * documentID in the given TextBase, LOW is a character	 * index into that document, and LENGTH is the length in	 * characters of the span that will be created as given type TYPE.	 * If LENGTH==-1, then the created span will go to the end of the	 * document.   *   * For closeType:   *   Lines must be <code>closeType ID TYPE</code> where ID is a documentID in the given TextBase   * and TYPE is the label type to close over that document.   *   * For closeAllTypes:   *   Lines must be <code>closeAllType ID</code> where ID is a documentID in the given TextBase.   * The document will be closed for all types present in the TextLabels <em>after all operations</em> are performed.	 *   * For setClosure:   *  Lines must be <code>setClosure POLICY</code> where POLICY is one of the policy types defined in this class.   * It will immediately change the closure policy for the loader.  This is best used at the beginning of   * the file to indicate one of the generic policies or the CLOSE_BY_OPERATION (default) policy.   */	public void importOps(MutableTextLabels labels,TextBase base,File file) throws IOException,FileNotFoundException	{    base = labels.getTextBase();    if (base == null)      throw new IllegalStateException("TextBase attached to labels must not be null");		LineNumberReader in = new LineNumberReader(new FileReader(file));		String line = null;		Set typeSet = new TreeSet();    List docList = new ArrayList();    try    {      while ((line = in.readLine())!=null)      {        if (line.trim().length() == 0)          continue;        log.debug("read line #" + in.getLineNumber() + ": " + line);        StringTokenizer tok = new StringTokenizer(line);        String op;        try { op = advance(tok, in, file); }        catch (IllegalArgumentException e)        { throw getNewException(e, ", failed to find operation."); }        if ("addToType".equals(op))        { addToType(tok, in, file, base, labels, typeSet); }        else if ("#".equals(op))        { continue; } //ignore comments        else if ("setClosure".equals(op))        {          //Set closure policy according to the name given          //which must match one of the give names          String policy = advance(tok, in, file);          int i = 0;          while (i < CLOSURE_NAMES.length)          {            if (CLOSURE_NAMES[i].equals(policy))            {              this.setClosurePolicy(i + 1);              break;            }            i++;          }          if (i == CLOSURE_NAMES.length)            log.warn("closure policy name in operation on line " + in.getLineNumber() + " is not a valid policy name, see TextLabelsLoader for valid names.");        }        else if ("closeType".equals(op))        {          if (this.closurePolicy != CLOSE_BY_OPERATION)          {            log.warn("you can only use closure operations when TLL's policy is CLOSE_BY_OPERATION \n"            + "Skipping operation on line " + in.getLineNumber() + " of " + file.getName());          }          else          {            String docId = advance(tok, in, file);            String type = advance(tok, in, file);            Span span = base.documentSpan(docId);            labels.closeTypeInside(type, span);            log.debug("closed " + type + " on " + docId);          }        }        else if ("closeAllTypes".equalsIgnoreCase(op))        {          String docId = advance(tok, in, file);          docList.add(docId);        } else {          throw new IllegalArgumentException("error on line "+in.getLineNumber()+" of "+file.getName());        }      }      //close over the doc list for all types seen      for (int i = 0; i < docList.size(); i++)      {        String docId = (String)docList.get(i);        Span span = base.documentSpan(docId);        closeLabels(labels.getTypes(), labels, span);      }    }    catch (IllegalArgumentException e)    {      throw getNewException(e, " on line: " +line);    }		in.close();		closeLabels(labels,closurePolicy);	}  private void addToType(StringTokenizer tok, LineNumberReader in, File file, TextBase base, MutableTextLabels labels, Set typeSet)  {    String id = advance(tok,in,file);    String loStr = advance(tok,in,file);    String lenStr = advance(tok,in,file);    String type = advance(tok,in,file);    int lo,len;    try {      lo = Integer.parseInt(loStr);      len = Integer.parseInt(lenStr);      Span span = base.documentSpan(id);      if (span==null) {          log.warn("unknown id '"+id+"'");      } else {        if (lo==0 && len<0) labels.addToType( span,type );        else {          if (len<0) len = span.asString().length()-lo;          labels.addToType( span.charIndexSubSpan(lo,lo+len),type );          typeSet.add( type );        }      }    } catch (NumberFormatException e) {      throw new IllegalArgumentException("bad number on line "+in.getLineNumber()+" of "+file.getName());    }  }  private static IllegalArgumentException getNewException(IllegalArgumentException e, String addToMsg)  {    String msg = e.getMessage() + addToMsg;    StackTraceElement[] trace = e.getStackTrace();    IllegalArgumentException exception = new IllegalArgumentException(msg);    exception.setStackTrace(trace);    return exception;  }	private String advance(StringTokenizer tok,LineNumberReader in,File file) {		if (!tok.hasMoreTokens())			throw new IllegalArgumentException("error on line "+in.getLineNumber()+" of "+file.getName() + " failed to find token");		return tok.nextToken();	}  /**   * Close labels on the labels according to the policy.  This applies the same   * policy to all documents and types in the labels.  To get finer control of closure   * use closeLabels(Set, MutableTextLabels, Span) or MutableTextLabels.closeTypeInside(...)   * @param labels   * @param policy   */	public void closeLabels(MutableTextLabels labels,int policy)	{		Set typeSet = labels.getTypes();		TextBase base = labels.getTextBase();    switch (policy)    {      case CLOSE_ALL_TYPES:        for (Span.Looper i=base.documentSpanIterator(); i.hasNext(); ) {          Span document = i.nextSpan();          closeLabels(typeSet, labels, document);        }        break;      case CLOSE_TYPES_IN_LABELED_DOCS:        for (Iterator j=typeSet.iterator(); j.hasNext(); ) {          String type = (String)j.next();          for (Span.Looper i=labels.instanceIterator(type); i.hasNext(); ) {            Span span = i.nextSpan();            labels.closeTypeInside( type, span.documentSpan() );          }        }        break;      case DONT_CLOSE_TYPES: //do nothing for this        break;      case CLOSE_BY_OPERATION: //already closed in theory        break;      default:        log.warn("closure policy(" + policy + ") not recognized");		}	}  /**   * Close all types in the typeSet on the given document   * @param typeSet set of types to close for this document   * @param labels TextLabels holding the types   * @param document Span to close types over   */  private void closeLabels(Set typeSet, MutableTextLabels labels, Span document)  {    for (Iterator j=typeSet.iterator(); j.hasNext(); ) {      String type = (String)j.next();      labels.closeTypeInside( type, document );    }  }  /** Read in a serialized TextLabels. */	public MutableTextLabels loadSerialized(File file,TextBase base) throws IOException,FileNotFoundException	{		try {			ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(new FileInputStream(file)));			MutableTextLabels labels = (MutableTextLabels)in.readObject();			labels.setTextBase(base);			in.close();			return labels;		}		catch (ClassNotFoundException e) {			throw new IllegalArgumentException("can't read TextLabels from "+file+": "+e);		}	}	/** Serialize a TextLabels. */	public void saveSerialized(MutableTextLabels labels, File file) throws IOException {		ObjectOutputStream out =	new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(file)));		out.writeObject( labels );		out.flush();		out.close();	}	/** Save extracted data in a format readable with loadOps. */	public void saveTypesAsOps(TextLabels labels,File file) throws IOException	{		PrintStream out = new PrintStream(new FileOutputStream(file));		for (Iterator i=labels.getTypes().iterator(); i.hasNext(); ) {			String type = (String)i.next();			for (Span.Looper j=labels.instanceIterator(type); j.hasNext(); ) {				Span s = j.nextSpan();				if (s.size()>0) {					int lo = s.getTextToken(0).getLo();					int hi = s.getTextToken(s.size()-1).getHi();					out.println("addToType "+s.getDocumentId()+" "+lo+" "+(hi-lo)+" "+type);				}			}      Span.Looper it = labels.closureIterator(type);      while (it.hasNext())      {        Span s = it.nextSpan();        out.println("closeType " + s.getDocumentId() + " " + type);      }		}		out.close();	}	/** Save spans of given type into the file, one per line.	 * Linefeeds in strings are replaced with spaces.	 */	public void saveTypesAsStrings(TextLabels labels,String type,File file) throws IOException	{		PrintStream out = new PrintStream(new FileOutputStream(file));		for (Span.Looper i=labels.instanceIterator(type); i.hasNext(); ) {			String s = i.nextSpan().asString().replace('\n',' ');			out.println( s );		}		out.close();	}	/** Save extracted data in an XML format.  Convert to string	 * &lt;root>..&lt;type>...&lt;/type>..&lt;/root> nested things &lt;a>A&lt;b>B&lt;/b>C&lt;/a>	 * are stored as nested things &lt;a>A&lt;set v=a,b>B&lt;/set>C&lt;/a> where	 * single sets are simplified so mismatches like [A (B C] D)E are	 * stored as &lt;a>a&lt;set v=a,b>B C&lt;/set>&lt;/a>&lt;b>D&lt;/b>E */	public String markupDocumentSpan(String documentId,TextLabels labels) {		TreeMap boundaries = new TreeMap();		for (Iterator i=labels.getTypes().iterator(); i.hasNext(); ) {			String type = (String)i.next();			for (Span.Looper j=labels.instanceIterator(type, documentId); j.hasNext(); ) {				Span s = j.nextSpan();				setBoundary(boundaries,"begin",type,s.getLeftBoundary());				setBoundary(boundaries,"end",type,s.getRightBoundary());			}		}		// now walk thru boundaries and find out which set as		// associated with each segment - want map from boundaries to		// type sets		String source = labels.getTextBase().documentSpan(documentId).asString();		//System.out.println("source is "+source);		StringBuffer buf = new StringBuffer("");		buf.append("<root>");		int currentPos = 0;		Set currentTypes = new TreeSet();		String lastMarkup = null;		for (Iterator i=boundaries.keySet().iterator(); i.hasNext(); ) {			Span b = (Span)i.next();			//System.out.println("b="+b);			// work out what types are in effect here			Set ops = (Set)boundaries.get(b);			for (Iterator j=ops.iterator(); j.hasNext(); ) {				String[] op = (String[]) j.next();				//System.out.println("op is "+op[0]+","+op[1]);				if ("begin".equals(op[0])) currentTypes.add(op[1]);				else currentTypes.remove(op[1]);			}			// output next section of document			int pos;			if (b.documentSpanStartIndex() < b.documentSpan().size())				pos = b.documentSpan().subSpan( b.documentSpanStartIndex(), 1).getTextToken(0).getLo();			else				pos = b.documentSpan().getTextToken(b.documentSpan().size()-1).getHi();			//System.out.println("boundary "+pos+" currentTypes="+currentTypes);			buf.append( source.substring(currentPos, pos) );			// close off last markup			if (lastMarkup!=null) buf.append("</"+lastMarkup+">");			// work out next markup symbol			String markup = null;			String value = null;			if (currentTypes.size()==1) {				markup = (String) (currentTypes.iterator().next());			} else if (currentTypes.size()>1) {				markup = "overlap";				StringBuffer vBuf = new StringBuffer("");				for (Iterator j=currentTypes.iterator(); j.hasNext(); ) {					if (vBuf.length()>0) vBuf.append(",");					vBuf.append( (String) j.next() );				}				value = vBuf.toString();			}			if (markup!=null && value!=null) {				buf.append("<"+markup+" value=\""+value+"\">");			} else if (markup!=null) {				buf.append("<"+markup+">");			}			// update position, lastMarkup			currentPos = pos;			lastMarkup = markup;			//System.out.println("after update buf='"+buf+"'");		} // each boundary		// close it all off		buf.append(source.substring(currentPos,source.length()));		buf.append("</root>");		return buf.toString();	}	private void setBoundary(TreeMap boundaries,String beginOrEnd,String type,Span s) {		Set ops = (Set)boundaries.get(s);		if (ops==null) boundaries.put(s, (ops = new HashSet()) );		ops.add( new String[] { beginOrEnd, type } );	}	/** Save extracted data in an XML format */	public String saveTypesAsXML(TextLabels labels) {		StringBuffer buf = new StringBuffer("<extractions>\n");		for (Iterator i=labels.getTypes().iterator(); i.hasNext(); ) {			String type = (String)i.next();			for (Span.Looper j=labels.instanceIterator(type); j.hasNext(); ) {				Span s = j.nextSpan();				int lo = s.getTextToken(0).getLo();				int hi = s.getTextToken(s.size()-1).getHi();				buf.append("  <"+type+" lo="+lo+" hi="+hi+">"+s.asString()+"</"+type+">\n");			}		}		buf.append("</extractions>\n");		return buf.toString();	}}